---
layout: post
title:  LeetCode刷题笔记 9月
date:   2019-09-01 01:00:00 -0400
categories: 不周山
tag: Leetcode
---


* content
{:toc}

[Go to Leetcode](https://www.evernote.com/shard/s588/sh/3d35f48d-0506-4091-b714-2c7fd2cbe932/ffd5af217c35393980b68fbb86b3dc56)
# 2019-09-02
## 155. Min Stack
### Description
Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.

push(x) -- Push element x onto stack.
pop() -- Removes the element on top of the stack.
top() -- Get the top element.
getMin() -- Retrieve the minimum element in the stack.
 
```
Example:

MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --> Returns -3.
minStack.pop();
minStack.top();      --> Returns 0.
minStack.getMin();   --> Returns -2.
```

### Solution
```java
class MinStack {

    Stack<Integer> stack;
    int min;
    /** initialize your data structure here. */
    public MinStack() {
        stack = new Stack<>();
        min = Integer.MAX_VALUE;
    }
    
    public void push(int x) {
        if(x <= min){
            stack.push(min);
            min = x;
        }
        stack.push(x);
    }
    
    public void pop() {
        int peek = stack.pop();
        //right now the min value must be the one before cur position
        //as the order theyt pushed into the stack.
        if(peek == min){
            min = stack.pop();
        }
    }
    
    public int top() {
        return stack.peek();
    }
    
    public int getMin() {
        return min;
    }
}

```

# 2019-09-03
## 127. Word Ladder
### Description
Given two words (beginWord and endWord), and a dictionary's word list, find the length of shortest transformation sequence from beginWord to endWord, such that:

Only one letter can be changed at a time.
Each transformed word must exist in the word list. Note that beginWord is not a transformed word.
Note:

Return 0 if there is no such transformation sequence.
All words have the same length.
All words contain only lowercase alphabetic characters.
You may assume no duplicates in the word list.
You may assume beginWord and endWord are non-empty and are not the same.
```
Example 1:

Input:
beginWord = "hit",
endWord = "cog",
wordList = ["hot","dot","dog","lot","log","cog"]

Output: 5

Explanation: As one shortest transformation is "hit" -> "hot" -> "dot" -> "dog" -> "cog",
return its length 5.
Example 2:

Input:
beginWord = "hit"
endWord = "cog"
wordList = ["hot","dot","dog","lot","log"]

Output: 0
```
Explanation: The endWord "cog" is not in wordList, therefore no possible transformation.

### Solution
```java
public class Solution {

public int ladderLength(String beginWord, String endWord, List<String> wordList) {
    Set<String> wordSet = new HashSet<String>(wordList);
    if(!wordSet.contains(endWord)) return 0;
    Set<String> beginSet = new HashSet<String>(), endSet = new HashSet<String>();

    int len = 1;
    HashSet<String> visited = new HashSet<String>();
    
    beginSet.add(beginWord);
    endSet.add(endWord);
    while (!beginSet.isEmpty() && !endSet.isEmpty()) {
        //exchange two set to ensure beginset is smaller so it will run faster.
        if (beginSet.size() > endSet.size()) {
            Set<String> set = beginSet;
            beginSet = endSet;
            endSet = set;
        }

        Set<String> temp = new HashSet<String>();
        for (String word : beginSet) {
            char[] chs = word.toCharArray();

            for (int i = 0; i < chs.length; i++) {
                for (char c = 'a'; c <= 'z'; c++) {
                    //main idea is to try every word and see if it's in the endSet.
                    char old = chs[i];
                    chs[i] = c;
                    String target = String.valueOf(chs);

                    //when it comes to end. endset is all word that can be reached.
                    if (endSet.contains(target)) {
                        return len + 1;
                    }

                    if (!visited.contains(target) && wordSet.contains(target)) {
                        temp.add(target);
                        visited.add(target);
                    }
                    chs[i] = old;
                }
            }
        }

        beginSet = temp;
        len++;
    }
    
    return 0;
}
}
```

# 2019-09-05
## 322. Coin Change
### Description
You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.
```
Example 1:

Input: coins = [1, 2, 5], amount = 11
Output: 3 
Explanation: 11 = 5 + 5 + 1
Example 2:

Input: coins = [2], amount = 3
Output: -1
```
Note:
You may assume that you have an infinite number of each kind of coin.
### Solution
```java
class Solution {
    public int coinChange(int[] coins, int amount) {
        int[] dp = new int[amount+1];
        Arrays.fill(dp,Integer.MAX_VALUE);
        dp[0] = 0;
        for(int i = 1;i<=amount;i++){
            for(int coin : coins){
                //try each coin and see the min value of dp[i-coin]+1 or dp[i] itself.
                if(coin <= i && dp[i-coin]!=Integer.MAX_VALUE){
                    dp[i] = Math.min(dp[i-coin]+1,dp[i]);
                }
            }
        }
        return dp[amount]==Integer.MAX_VALUE?-1:dp[amount];
    }
}
```

## 986. Interval List Intersections
### Description
Given two lists of closed intervals, each list of intervals is pairwise disjoint and in sorted order.

Return the intersection of these two interval lists.

(Formally, a closed interval `[a, b] (a <= b)` denotes the set of real numbers x with a <= x <= b.  The intersection of two closed intervals is a set of real numbers that is either empty, or can be represented as a closed interval.  For example, the intersection of [1, 3] and [2, 4] is [2, 3].)

 
```
Example 1:
Input: A = [[0,2],[5,10],[13,23],[24,25]], B = [[1,5],[8,12],[15,24],[25,26]]
Output: [[1,2],[5,5],[8,10],[15,23],[24,24],[25,25]]
Reminder: The inputs and the desired output are lists of Interval objects, and not arrays or lists.
```

### Solution
```java
class Solution {
    public int[][] intervalIntersection(int[][] A, int[][] B) {
        if(null == A || null == B || A.length==0 || B.length==0){
            return new int[][]{};
        }
        List<int[]> res = new ArrayList();
        //main idea is two pointer.
        int i = 0, j=0;
        while(i<A.length && j<B.length){
            int[] a = A[i];
            int[] b = B[j];
            
            //find interval.
            int startMax = Math.max(a[0],b[0]);
            int endMin = Math.min(a[1],b[1]);
            if(startMax<=endMin){
                res.add(new int[]{startMax,endMin});
            }
            
            //if the interval end is smaller, move on to the next.
            if(endMin == a[1])i++;
            if(endMin == b[1])j++;
            
        }
        int[][] res_b = new int[res.size()][2];
        
        return res.toArray(res_b);
    }
}
```

# 2019-09-08
## 221. Maximal Square
### Description
Given a 2D binary matrix filled with 0's and 1's, find the largest square containing only 1's and return its area.
```
Example:

Input: 

1 0 1 0 0
1 0 1 1 1
1 1 1 1 1
1 0 0 1 0

Output: 4
```

### Solution
```java
class Solution {
    public int maximalSquare(char[][] matrix) {
        if(null == matrix || matrix.length==0){
            return 0;
        }
        int yLength = matrix.length;
        int xLength = matrix[0].length;
        int[][] dp = new int[yLength+1][xLength+1];
        int max = 0;
        for(int i = 1;i<=yLength;i++){
            for(int j = 1;j<=xLength;j++){
                if(matrix[i-1][j-1]=='1'){
                    //dp[i][j] is limited by its neighbor.
                    dp[i][j] = Math.min(dp[i-1][j-1],Math.min(dp[i-1][j],dp[i][j-1]))+1;
                    max = Math.max(max,dp[i][j]);
                }
            }
        }
        return max * max;
    }
}
```

# 2019-09-11
## 6. ZigZag Conversion
### Description
The string "PAYPALISHIRING" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)

P   A   H   N
A P L S I I G
Y   I   R
And then read line by line: "PAHNAPLSIIGYIR"

Write the code that will take a string and make this conversion given a number of rows:

string convert(string s, int numRows);
```
Example 1:

Input: s = "PAYPALISHIRING", numRows = 3
Output: "PAHNAPLSIIGYIR"

Example 2:

Input: s = "PAYPALISHIRING", numRows = 4
Output: "PINALSIGYAHRPI"
Explanation:

P     I    N
A   L S  I G
Y A   H R
P     I
```
### Solution
```java
//Using slot.
class Solution {
    public String convert(String s, int numRows) {
    
        if(numRows==1){
            return s;
        }
        int len = s.length();
        int i = 0;
        int index = 0;
        boolean reverse = true;
        StringBuilder[] sb = new StringBuilder[numRows];
        for(int j = 0;j<numRows;j++){
            sb[j] = new StringBuilder();
        }
        while(i<len){
            sb[index].append(s.charAt(i));
            if(index==numRows-1){
                index--;
                reverse = !reverse;
            }else if(index==0){
                index++;
                reverse = !reverse;
            }else{
                if(reverse)index--;
                else index++;
            }
            i++;
        }
        StringBuilder sbRes = new StringBuilder();
        for(StringBuilder _sb:sb){
            sbRes.append(_sb.toString());
        }
        return sbRes.toString();
    }
    
    
}
```

## 364. Nested List Weight Sum II
### Description
Given a nested list of integers, return the sum of all integers in the list weighted by their depth.

Each element is either an integer, or a list -- whose elements may also be integers or other lists.

Different from the previous question where weight is increasing from root to leaf, now the weight is defined from bottom up. i.e., the leaf level integers have weight 1, and the root level integers have the largest weight.
```
Example 1:

Input: [[1,1],2,[1,1]]
Output: 8 
Explanation: Four 1's at depth 1, one 2 at depth 2.
Example 2:

Input: [1,[4,[6]]]
Output: 17 
Explanation: One 1 at depth 3, one 4 at depth 2, and one 6 at depth 1; 1*3 + 4*2 + 6*1 = 17.
```

### Solution
```java
class Solution {
    public int depthSumInverse(List<NestedInteger> nestedList) {
        int weighted = 0, unweighted = 0;
        while(!nestedList.isEmpty()){
            List<NestedInteger> temp = new LinkedList<>();
            for(NestedInteger n:nestedList){
                if(n.isInteger()){
                    unweighted += n.getInteger();
                }else{
                    temp.addAll(n.getList());
                }
            }
            nestedList = temp;
            weighted += unweighted;
        }
        return weighted;
    }
}
```
