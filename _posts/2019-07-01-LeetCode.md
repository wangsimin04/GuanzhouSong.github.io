---
layout: post
title:  LeetCode刷题笔记 7月
date:   2019-07-01 01:00:00 -0400
categories: 不周山
tag: Leetcode
---


* content
{:toc}

[Go to Leetcode](https://www.evernote.com/shard/s588/sh/3d35f48d-0506-4091-b714-2c7fd2cbe932/ffd5af217c35393980b68fbb86b3dc56)
# 2019-07-01
## 394. Decode String
### Description
Given an encoded string, return its decoded string.

The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer.

You may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc.

Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. For example, there won't be input like 3a or 2[4].
```
Examples:

s = "3[a]2[bc]", return "aaabcbc".
s = "3[a2[c]]", return "accaccacc".
s = "2[abc]3[cd]ef", return "abcabccdcdcdef".
```

### Solution
```java
class Solution {
	//there are four situations:
	//1. digits: should count all the possible number and add to stack.
	//2. letter: just add to res.
	//3. [: should first put all the words before to resStk, then set res to empty.
	//4. ]: should start wrapping up. first get a count from countStk, then pop a string from resStk, which is the result after the [ and number.
	// then add current res, which is the result in the [], for cout times. then make the current string as res.
    public String decodeString(String s) {
        String res = "";
        Stack<Integer> countStk = new Stack();
        Stack<String> resStk = new Stack();
        int idx = 0;
        while(idx < s.length()){
            if(Character.isDigit(s.charAt(idx))){
                int count = 0;
                while(Character.isDigit(s.charAt(idx))){
                    count = count * 10 + (s.charAt(idx)-'0');
                    idx++;
                }
                countStk.push(count);
            }else if(s.charAt(idx) == '['){
                resStk.push(res);
                res = "";
                idx++;
            }else if(s.charAt(idx) == ']'){
                StringBuilder sb = new StringBuilder(resStk.pop());
                int count = countStk.pop();
                for(int i=0;i<count;i++){
                    sb.append(res);
                }
                res = sb.toString();
                idx++;
            }else{
                res += s.charAt(idx++);
            }
        }
        return res;
    }

    // use maxHeap. Put entry into maxHeap so we can always poll a number with largest frequency
    public List<Integer> topKFrequent2(int[] nums, int k) {
        Map<Integer, Integer> map = new HashMap();
        for(int n: nums){
            map.put(n,map.getOrDefault(n,0)+1);
        }
        
        //PriorityQueue
        PriorityQueue<Map.Entry<Integer,Integer>> maxHeap = 
            new PriorityQueue<>((a,b)->(b.getValue()-a.getValue()));
        
        for(Map.Entry<Integer,Integer> entry : map.entrySet()){
            maxHeap.add(entry);
        }
        List<Integer> res = new LinkedList();
        while(res.size()<k){
            Map.Entry<Integer,Integer> entry = maxHeap.poll();
            res.add(entry.getKey());
        }
        return res;
    }

	// use treeMap. Use freqncy as the key so we can get all freqencies in order
    public List<Integer> topKFrequent(int[] nums, int k) {
        Map<Integer, Integer> map = new HashMap<>();
        for(int n: nums){
            map.put(n, map.getOrDefault(n,0)+1);
        }
        
        TreeMap<Integer,List<Integer>> freqMap = new TreeMap();
        for(int num: map.keySet()){
            int freq=  map.get(num);
            if(!freqMap.containsKey(freq)){
                freqMap.put(freq,new LinkedList());
            }
            freqMap.get(freq).add(num);
        }
               
        List<Integer> res = new LinkedList();
        while(res.size()<k){
            Map.Entry<Integer, List<Integer>> entry = freqMap.pollLastEntry();
            res.addAll(entry.getValue());
        }
        return res;
    }
}
```





#2019-07-11
## 56. Merge Intervals
### Desc
Given a collection of intervals, merge all overlapping intervals.
```
Example 1:

Input: [[1,3],[2,6],[8,10],[15,18]]
Output: [[1,6],[8,10],[15,18]]
Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].
Example 2:

Input: [[1,4],[4,5]]
Output: [[1,5]]
Explanation: Intervals [1,4] and [4,5] are considered overlapping.
```

### Solution
```java
class Solution {
    public int[][] merge(int[][] intervals) {
        if(intervals.length < 2){
            return intervals;
        }
        //remember to sort in order of first element.
        //normal order as increasing, should first minus second.
        Arrays.sort(intervals,(a,b)->(a[0]-b[0]));
        List<int[]> res = new ArrayList();
        //record the current interval.
        int[] pre = intervals[0];
        for(int i =1;i<intervals.length;i++){
            int[] cur = intervals[i];
            //if not overlap, then add to res and start a new record.
            if(pre[1] < cur[0]){
                res.add(pre);
                pre = cur;
            }else{
                pre[1] = Math.max(cur[1],pre[1]);
            }
        }
        
        res.add(pre);
        return res.toArray(new int[res.size()][]);
    }
}

```

## 253. Meeting Rooms II
### Desc
Given an array of meeting time intervals consisting of start and end times [[s1,e1],[s2,e2],...] (si < ei), find the minimum number of conference rooms required.
```
Example 1:

Input: [[0, 30],[5, 10],[15, 20]]
Output: 2
Example 2:

Input: [[7,10],[2,4]]
Output: 1

```

### Solution
```java
class Solution {
    public int minMeetingRooms(int[][] intervals) {
        if(intervals==null || intervals.length == 0){
            return 0;
        }
        int max = 0;
        //sort start time.
        Arrays.sort(intervals,(a,b)->(a[0]-b[0]));
        //max heap for end time.
        PriorityQueue<int[]> pq = new PriorityQueue<>(intervals.length,(a,b)->(a[1]-b[1]));
        for(int i = 0;i<intervals.length;i++){
            while(!pq.isEmpty() && intervals[i][0] >= pq.peek()[1])
                //remove all not overlaped previous meeting.
                pq.poll();
            pq.offer(intervals[i]);
            //count the current overlaped meetings.
            max = Math.max(max,pq.size());
        }
        return max;
    }
}
```
