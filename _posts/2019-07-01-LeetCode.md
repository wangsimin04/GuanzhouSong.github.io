---
layout: post
title:  LeetCode刷题笔记 7月
date:   2019-07-01 01:00:00 -0400
categories: 不周山
tag: Leetcode
---


* content
{:toc}

[Go to Leetcode](https://www.evernote.com/shard/s588/sh/3d35f48d-0506-4091-b714-2c7fd2cbe932/ffd5af217c35393980b68fbb86b3dc56)
# 2019-07-01
## 394. Decode String
### Description
Given an encoded string, return its decoded string.

The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer.

You may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc.

Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. For example, there won't be input like 3a or 2[4].
```
Examples:

s = "3[a]2[bc]", return "aaabcbc".
s = "3[a2[c]]", return "accaccacc".
s = "2[abc]3[cd]ef", return "abcabccdcdcdef".
```

### Solution
```java
class Solution {
	//there are four situations:
	//1. digits: should count all the possible number and add to stack.
	//2. letter: just add to res.
	//3. [: should first put all the words before to resStk, then set res to empty.
	//4. ]: should start wrapping up. first get a count from countStk, then pop a string from resStk, which is the result after the [ and number.
	// then add current res, which is the result in the [], for cout times. then make the current string as res.
    public String decodeString(String s) {
        String res = "";
        Stack<Integer> countStk = new Stack();
        Stack<String> resStk = new Stack();
        int idx = 0;
        while(idx < s.length()){
            if(Character.isDigit(s.charAt(idx))){
                int count = 0;
                while(Character.isDigit(s.charAt(idx))){
                    count = count * 10 + (s.charAt(idx)-'0');
                    idx++;
                }
                countStk.push(count);
            }else if(s.charAt(idx) == '['){
                resStk.push(res);
                res = "";
                idx++;
            }else if(s.charAt(idx) == ']'){
                StringBuilder sb = new StringBuilder(resStk.pop());
                int count = countStk.pop();
                for(int i=0;i<count;i++){
                    sb.append(res);
                }
                res = sb.toString();
                idx++;
            }else{
                res += s.charAt(idx++);
            }
        }
        return res;
    }

    // use maxHeap. Put entry into maxHeap so we can always poll a number with largest frequency
    public List<Integer> topKFrequent2(int[] nums, int k) {
        Map<Integer, Integer> map = new HashMap();
        for(int n: nums){
            map.put(n,map.getOrDefault(n,0)+1);
        }
        
        //PriorityQueue
        PriorityQueue<Map.Entry<Integer,Integer>> maxHeap = 
            new PriorityQueue<>((a,b)->(b.getValue()-a.getValue()));
        
        for(Map.Entry<Integer,Integer> entry : map.entrySet()){
            maxHeap.add(entry);
        }
        List<Integer> res = new LinkedList();
        while(res.size()<k){
            Map.Entry<Integer,Integer> entry = maxHeap.poll();
            res.add(entry.getKey());
        }
        return res;
    }

	// use treeMap. Use freqncy as the key so we can get all freqencies in order
    public List<Integer> topKFrequent(int[] nums, int k) {
        Map<Integer, Integer> map = new HashMap<>();
        for(int n: nums){
            map.put(n, map.getOrDefault(n,0)+1);
        }
        
        TreeMap<Integer,List<Integer>> freqMap = new TreeMap();
        for(int num: map.keySet()){
            int freq=  map.get(num);
            if(!freqMap.containsKey(freq)){
                freqMap.put(freq,new LinkedList());
            }
            freqMap.get(freq).add(num);
        }
               
        List<Integer> res = new LinkedList();
        while(res.size()<k){
            Map.Entry<Integer, List<Integer>> entry = freqMap.pollLastEntry();
            res.addAll(entry.getValue());
        }
        return res;
    }
}
```


