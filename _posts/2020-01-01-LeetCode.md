---
layout: post
title:  LeetCode刷题笔记 1月
date:   2020-01-01 11:00:00 -0400
categories: 不周山
tag: Leetcode
---


* content
{:toc}

[Go to Leetcode](https://www.evernote.com/shard/s588/sh/3d35f48d-0506-4091-b714-2c7fd2cbe932/ffd5af217c35393980b68fbb86b3dc56)

# 2020-01-16
## 994. Rotting Oranges
### Descripsion
In a given grid, each cell can have one of three values:

the value 0 representing an empty cell;
the value 1 representing a fresh orange;
the value 2 representing a rotten orange.
Every minute, any fresh orange that is adjacent (4-directionally) to a rotten orange becomes rotten.

Return the minimum number of minutes that must elapse until no cell has a fresh orange.  If this is impossible, return -1 instead.

 
```
Example 1:

Input: [[2,1,1],[1,1,0],[0,1,1]]
Output: 4
Example 2:

Input: [[2,1,1],[0,1,1],[1,0,1]]
Output: -1
Explanation:  The orange in the bottom left corner (row 2, column 0) is never rotten, because rotting only happens 4-directionally.
Example 3:

Input: [[0,2]]
Output: 0
Explanation:  Since there are already no fresh oranges at minute 0, the answer is just 0.
```

Note:

1 <= grid.length <= 10
1 <= grid[0].length <= 10
grid[i][j] is only 0, 1, or 2.

### Solution
```java
class Solution {

	//First, count fresh oranges. Then, until fresh is non-zero, perform BFS to rot oranges, decreasing fresh. Count days (d) and return it in the end. If, after another day, fresh does not change, return -1.

	//For BFS, we can use the day counter (d + 2) to only process oranges that rotted yesterday.

    public int orangesRotting(int[][] grid) {
        int fresh = 0;
        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[i].length; j++) {
                if (grid[i][j] == 1) {
                    fresh++;
                }
            }
        }
        int day = 0;
        for (int old_fresh = fresh; fresh > 0; old_fresh = fresh, day++) {
            for (int i = 0; i < grid.length; i++) {
                for (int j = 0; j < grid[i].length; j++) {
                    if (grid[i][j] == day + 2) {
                        fresh -= (rot(grid, i - 1, j, day) + rot(grid, i + 1, j, day) + rot(grid, i, j - 1, day) + rot(grid, i, j + 1, day));
                    }
                }
            }
            if (fresh == old_fresh) {
                return -1;
            }
        }
        return day;
    }

    private int rot(int[][] grid, int i, int j, int day) {
        if (i < 0 || j < 0 || i >= grid.length || j >= grid[i].length || grid[i][j] != 1) {
            return 0;
        }
        grid[i][j] = day + 3;
        return 1;
    }
}
```