---
layout: post
title:  LeetCode刷题笔记 1月
date:   2020-01-01 11:00:00 -0400
categories: 不周山
tag: Leetcode
---


* content
{:toc}

[Go to Leetcode](https://www.evernote.com/shard/s588/sh/3d35f48d-0506-4091-b714-2c7fd2cbe932/ffd5af217c35393980b68fbb86b3dc56)

# 2020-01-16
## 994. Rotting Oranges
### Descripsion
In a given grid, each cell can have one of three values:

the value 0 representing an empty cell;
the value 1 representing a fresh orange;
the value 2 representing a rotten orange.
Every minute, any fresh orange that is adjacent (4-directionally) to a rotten orange becomes rotten.

Return the minimum number of minutes that must elapse until no cell has a fresh orange.  If this is impossible, return -1 instead.

 
```
Example 1:

Input: [[2,1,1],[1,1,0],[0,1,1]]
Output: 4
Example 2:

Input: [[2,1,1],[0,1,1],[1,0,1]]
Output: -1
Explanation:  The orange in the bottom left corner (row 2, column 0) is never rotten, because rotting only happens 4-directionally.
Example 3:

Input: [[0,2]]
Output: 0
Explanation:  Since there are already no fresh oranges at minute 0, the answer is just 0.
```

Note:

1 <= grid.length <= 10
1 <= grid[0].length <= 10
grid[i][j] is only 0, 1, or 2.

### Solution
```java
class Solution {

	//First, count fresh oranges. Then, until fresh is non-zero, perform BFS to rot oranges, decreasing fresh. Count days (d) and return it in the end. If, after another day, fresh does not change, return -1.

	//For BFS, we can use the day counter (d + 2) to only process oranges that rotted yesterday.

    public int orangesRotting(int[][] grid) {
        int fresh = 0;
        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[i].length; j++) {
                if (grid[i][j] == 1) {
                    fresh++;
                }
            }
        }
        int day = 0;
        for (int old_fresh = fresh; fresh > 0; old_fresh = fresh, day++) {
            for (int i = 0; i < grid.length; i++) {
                for (int j = 0; j < grid[i].length; j++) {
                	//only process rotted yesterday.
                    if (grid[i][j] == day + 2) {
                        fresh -= (rot(grid, i - 1, j, day) + rot(grid, i + 1, j, day) + rot(grid, i, j - 1, day) + rot(grid, i, j + 1, day));
                    }
                }
            }
            //when still have fresh one but not able to rot it.
            if (fresh == old_fresh) {
                return -1;
            }
        }
        return day;
    }

    private int rot(int[][] grid, int i, int j, int day) {
        if (i < 0 || j < 0 || i >= grid.length || j >= grid[i].length || grid[i][j] != 1) {
            return 0;
        }
        //use day+3 to mark rotted, and only process the one rotted yesterday.
        grid[i][j] = day + 3;
        return 1;
    }
}
```

## 543. Diameter of Binary Tree
### Description
Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.

```
Example:
Given a binary tree
          1
         / \
        2   3
       / \     
      4   5    
Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3].
```
Note: The length of path between two nodes is represented by the number of edges between them.

### Solution
```java
public class Solution {
    int max = 0;

    public int diameterOfBinaryTree(TreeNode root) {
        maxDepth(root);
        return max;
    }

    private int maxDepth(TreeNode root) {
        if (root == null) return 0;

        int left = maxDepth(root.left);
        int right = maxDepth(root.right);

        max = Math.max(max, left + right);

        return Math.max(left, right) + 1;
    }
}

```