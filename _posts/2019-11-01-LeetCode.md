---
layout: post
title:  LeetCode刷题笔记 11月
date:   2019-11-01 01:00:00 -0400
categories: 不周山
tag: Leetcode
---


* content
{:toc}

[Go to Leetcode](https://www.evernote.com/shard/s588/sh/3d35f48d-0506-4091-b714-2c7fd2cbe932/ffd5af217c35393980b68fbb86b3dc56)
# 2019-11-02
## 539. Minimum Time Difference
### Description
Given a list of 24-hour clock time points in "Hour:Minutes" format, find the minimum minutes difference between any two time points in the list.
Example 1:
Input: ["23:59","00:00"]
Output: 1
Note:
The number of time points in the given list is at least 2 and won't exceed 20000.
The input time is legal and ranges from 00:00 to 23:59.

### Solution
```java
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

class Solution {

    public int findMinDifference(List<String> timePoints) {
        int[] times = new int[timePoints.size()];
        int count = 0;
        for (String time : timePoints) {
            times[count++] = convert(time);
        }
        Arrays.sort(times);
        int min = Integer.MAX_VALUE;
        for(int i = 0;i<times.length-1;i++){
            min = Math.min(min,times[i+1]-times[i]);
        }
        min = Math.min(min,Math.abs(times[0]+24*60-times[times.length-1]));
        return min;

    }

    private int convert(String time) {
        //use split will cause time waste.
        //since you know the format, can call them directly.
        int hour = 10 * (time.charAt(0) - '0') + (time.charAt(1) - '0');
        int minute = 10 * (time.charAt(3) - '0') + (time.charAt(4) - '0');
        return hour * 60 + minute;
    }


}

```

## 24. Swap Nodes in Pairs
### Description
Given a linked list, swap every two adjacent nodes and return its head.

You may not modify the values in the list's nodes, only nodes itself may be changed.

 

Example:

Given 1->2->3->4, you should return the list as 2->1->4->3.

### Solution
```java
/**
 * Definition for singly-linked list. public class ListNode { int val; ListNode next; ListNode(int x) { val = x; } }
 */
class Solution {

    public ListNode swapPairs(ListNode head) {
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode pre = dummy;
        ListNode cur = dummy.next;
        while (cur != null && cur.next != null) {
            ListNode sec = cur.next;
            cur.next = sec.next;
            sec.next = cur;
            pre.next = sec;
            pre = cur;
            cur = cur.next;
        }
        return dummy.next;
    }
}

```

## 71. Simplify Path
### Description
Given an absolute path for a file (Unix-style), simplify it. Or in other words, convert it to the canonical path.

In a UNIX-style file system, a period . refers to the current directory. Furthermore, a double period .. moves the directory up a level. For more information, see: Absolute path vs relative path in Linux/Unix

Note that the returned canonical path must always begin with a slash /, and there must be only a single slash / between two directory names. The last directory name (if it exists) must not end with a trailing /. Also, the canonical path must be the shortest string representing the absolute path.

 
```
Example 1:

Input: "/home/"
Output: "/home"
Explanation: Note that there is no trailing slash after the last directory name.
Example 2:

Input: "/../"
Output: "/"
Explanation: Going one level up from the root directory is a no-op, as the root level is the highest level you can go.
Example 3:

Input: "/home//foo/"
Output: "/home/foo"
Explanation: In the canonical path, multiple consecutive slashes are replaced by a single one.
Example 4:

Input: "/a/./b/../../c/"
Output: "/c"
Example 5:

Input: "/a/../../b/../c//.//"
Output: "/c"
Example 6:

Input: "/a//b////c/d//././/.."
Output: "/a/b/c"
```

### Solution
```java
class Solution {
    public String simplifyPath(String path) {
        Deque<String> stack = new LinkedList<>();
        for (String s : path.split("/")) {
            if (s.equals("..")) {
                //use poll() can avoid empty with pop()
                stack.poll();
            } else if (!s.equals("") && !s.equals(".")) {
                stack.push(s);
            }
        }
        StringBuilder sb = new StringBuilder();
        if (stack.size() == 0) {
            return "/";
        }
        while (stack.size() != 0) {
            sb.append("/").append(stack.pollLast());
        }
        return sb.toString();
    }
}
```

# 2019-11-03
## 173. Binary Search Tree Iterator
### Description
Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST.

Calling next() will return the next smallest number in the BST.

 
```
Example:

BSTIterator iterator = new BSTIterator(root);
iterator.next();    // return 3
iterator.next();    // return 7
iterator.hasNext(); // return true
iterator.next();    // return 9
iterator.hasNext(); // return true
iterator.next();    // return 15
iterator.hasNext(); // return true
iterator.next();    // return 20
iterator.hasNext(); // return false
 
```
Note:

next() and hasNext() should run in average O(1) time and uses O(h) memory, where h is the height of the tree.
You may assume that next() call will always be valid, that is, there will be at least a next smallest number in the BST when next() is called.

### Solution
```java
import java.util.Stack;

/**
 * Definition for a binary tree node. public class TreeNode { int val; TreeNode left; TreeNode
 * right; TreeNode(int x) { val = x; } }
 */
class BSTIterator {

    Stack<TreeNode> stack;

    public BSTIterator(TreeNode root) {
        stack = new Stack<>();
        pushAll(root);
    }

    /**
     * @return the next smallest number
     */
    public int next() {
        TreeNode cur = stack.pop();
        //next node will always on its right.
        pushAll(cur.right);
        return cur.val;
    }

    private void pushAll(TreeNode root) {
        while (root != null) {
            stack.push(root);
            root = root.left;
        }
    }

    /**
     * @return whether we have a next smallest number
     */
    public boolean hasNext() {
        return !stack.isEmpty();
    }
}

/**
 * Your BSTIterator object will be instantiated and called as such: BSTIterator obj = new
 * BSTIterator(root); int param_1 = obj.next(); boolean param_2 = obj.hasNext();
 */

```

## 328. Odd Even Linked List
### Description
Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes.

You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity.
```
Example 1:

Input: 1->2->3->4->5->NULL
Output: 1->3->5->2->4->NULL
Example 2:

Input: 2->1->3->5->6->4->7->NULL
Output: 2->3->6->7->1->5->4->NULL
```
Note:

The relative order inside both the even and odd groups should remain as it was in the input.
The first node is considered odd, the second node even and so on ...

### Solution
```java
/**
 * Definition for singly-linked list. public class ListNode { int val; ListNode next; ListNode(int
 * x) { val = x; } }
 */
class Solution {
    //We just need to form a linked list of all odd nodes(X) and another linked list of all even nodes(Y). Afterwards, we link Y to the end of X, and return the head of X.
    public ListNode oddEvenList(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }
        ListNode odd = head, even = head.next, evenHead = even;
        while (even != null && even.next != null) {
            odd.next = odd.next.next;
            even.next = even.next.next;
            odd = odd.next;
            even = even.next;
        }
        odd.next = evenHead;
        return head;
    }

}
```

## 304. Range Sum Query 2D - Immutable
### Description
Given a 2D matrix matrix, find the sum of the elements inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2).

Range Sum Query 2D
The above rectangle (with the red border) is defined by (row1, col1) = (2, 1) and (row2, col2) = (4, 3), which contains sum = 8.
```
Example:
Given matrix = [
  [3, 0, 1, 4, 2],
  [5, 6, 3, 2, 1],
  [1, 2, 0, 1, 5],
  [4, 1, 0, 1, 7],
  [1, 0, 3, 0, 5]
]

sumRegion(2, 1, 4, 3) -> 8
sumRegion(1, 1, 2, 2) -> 11
sumRegion(1, 2, 2, 4) -> 12
```
Note:
You may assume that the matrix does not change.
There are many calls to sumRegion function.
You may assume that row1 ≤ row2 and col1 ≤ col2.

### Solution

```java
class NumMatrix {

    int[][] sum;

    public NumMatrix(int[][] matrix) {
        
        int Y = matrix.length;
        //how to handle null matrix or matrix of size 0;
        if(Y==0) return;
        int X = matrix[0].length;
        sum = new int[Y][X];
        sum[0][0] = matrix[0][0];
        for (int x = 1; x < X; x++) {
            sum[0][x] = sum[0][x - 1] + matrix[0][x];
        }
        for (int y = 1; y < Y; y++) {
            sum[y][0] = sum[y - 1][0] + matrix[y][0];
        }
        for (int y = 1; y < Y; y++) {
            for (int x = 1; x < X; x++) {
                sum[y][x] = matrix[y][x] + sum[y - 1][x] + sum[y][x - 1] - sum[y - 1][x - 1];
            }
        }

    }

    public int sumRegion(int row1, int col1, int row2, int col2) {
        if (col1 - 1 < 0 && row1 - 1 < 0) {
            return sum[row2][col2];
        }
        if (col1 - 1 < 0) {
            return sum[row2][col2] + -sum[row1 - 1][col2];
        }
        if (row1 - 1 < 0) {
            return sum[row2][col2] + -sum[row2][col1 - 1];
        }
        return sum[row2][col2] + sum[row1 - 1][col1 - 1] - sum[row1 - 1][col2] - sum[row2][col1 - 1];
    }

    
}

/**
 * Your NumMatrix object will be instantiated and called as such: NumMatrix obj = new
 * NumMatrix(matrix); int param_1 = obj.sumRegion(row1,col1,row2,col2);
 */

```

## 698. Partition to K Equal Sum Subsets
### Description
Given an array of integers nums and a positive integer k, find whether it's possible to divide this array into k non-empty subsets whose sums are all equal.

 

Example 1:

Input: nums = [4, 3, 2, 3, 5, 2, 1], k = 4
Output: True
Explanation: It's possible to divide it into 4 subsets (5), (1, 4), (2,3), (2,3) with equal sums.
 

Note:

1 <= k <= len(nums) <= 16.
0 < nums[i] < 10000.


### Solution
```java
class Solution {

     public boolean canPartitionKSubsets(int[] nums, int k) {
        int sum = 0;
        for(int num:nums)sum += num;
        //sum cannot be divided by k then there's no way to split.
        if(k <= 0 || sum%k != 0)return false;
        int[] visited = new int[nums.length];
        return canPartition(nums, visited, 0, k, 0, 0, sum/k);
    }
    
    public boolean canPartition(int[] nums, int[] visited, int start_index, int k, int cur_sum, int cur_num, int target){
        //already found k-1 subsets then the rest is guarenteed to have sum k
        if(k==1)return true;
        //found a subset, and looking for next subset.
        //start from 0 to end, and look in the rest unvisited element.
        if(cur_sum == target && cur_num>0)return canPartition(nums, visited, 0, k-1, 0, 0, target);
        //will skip the loop and save lots of time.
        if(cur_sum>target) return false;
        for(int i = start_index; i<nums.length; i++){
            if(visited[i] == 0){
                visited[i] = 1;
                if(canPartition(nums, visited, i+1, k, cur_sum + nums[i], cur_num++, target))return true;
                visited[i] = 0;
            }
        }
        return false;
    }
}

```


## 179. Largest Number
### Description
Given a list of non negative integers, arrange them such that they form the largest number.

Example 1:

Input: [10,2]
Output: "210"
Example 2:

Input: [3,30,34,5,9]
Output: "9534330"
Note: The result may be very large, so you need to return a string instead of an integer.

### Solution
```java
import java.util.Arrays;
import java.util.Comparator;
import java.util.PriorityQueue;

class Solution {
    public String largestNumber(int[] nums) {
        if (nums == null || nums.length == 0)
            return "";
        String[] s_nums = new String[nums.length];
        for (int i = 0; i < nums.length; i++)
            s_nums[i] = String.valueOf(nums[i]);

        //compare by string but not integer.
        Comparator<String> comp = new Comparator<String>() {
            @Override
            public int compare(String o1, String o2) {
                String s1 =o1 + o2;
                String s2 = o2 + o1;
                return s2.compareTo(s1);
            }
        };
        Arrays.sort(s_nums,comp);
        if(s_nums[0].charAt(0) == '0')
                    return "0";
        StringBuilder sb =new StringBuilder();
        for(String s: s_nums){
            sb.append(s);
        }
        return sb.toString();

    }

}

```

# 2019-11-04
## 277. Find the Celebrity
### Description
Suppose you are at a party with n people (labeled from 0 to n - 1) and among them, there may exist one celebrity. The definition of a celebrity is that all the other n - 1 people know him/her but he/she does not know any of them.

Now you want to find out who the celebrity is or verify that there is not one. The only thing you are allowed to do is to ask questions like: "Hi, A. Do you know B?" to get information of whether A knows B. You need to find out the celebrity (or verify there is not one) by asking as few questions as possible (in the asymptotic sense).

You are given a helper function bool knows(a, b) which tells you whether A knows B. Implement a function int findCelebrity(n). There will be exactly one celebrity if he/she is in the party. Return the celebrity's label if there is a celebrity in the party. If there is no celebrity, return -1.

```
Example 1:


Input: graph = [
  [1,1,0],
  [0,1,0],
  [1,1,1]
]
Output: 1
Explanation: There are three persons labeled with 0, 1 and 2. graph[i][j] = 1 means person i knows person j, otherwise graph[i][j] = 0 means person i does not know person j. The celebrity is the person labeled as 1 because both 0 and 2 know him but 1 does not know anybody.
Example 2:


Input: graph = [
  [1,0,1],
  [1,1,0],
  [0,1,1]
]
Output: -1
Explanation: There is no celebrity.
 
```
Note:

The directed graph is represented as an adjacency matrix, which is an n x n matrix where a[i][j] = 1 means person i knows person j while a[i][j] = 0 means the contrary.
Remember that you won't have direct access to the adjacency matrix.

### Solution
```java
/* The knows API is defined in the parent class Relation.
      boolean knows(int a, int b); */
//no need build a graph and implement topological sort.
public class Solution extends Relation {

    public int findCelebrity(int n) {
        int candidate = 0;
        for (int i = 1; i < n; i++) {
            if(knows(candidate,i)) candidate = i;
        }

        for(int i = 0;i<n;i++){
            if(i !=candidate && (knows(candidate,i) || !knows(i,candidate)))
                return -1;
        }
        return candidate;
    }
}

```

## 211. Add and Search Word - Data structure design
### Description
Design a data structure that supports the following two operations:

void addWord(word)
bool search(word)
search(word) can search a literal word or a regular expression string containing only letters a-z or .. A . means it can represent any one letter.
```
Example:

addWord("bad")
addWord("dad")
addWord("mad")
search("pad") -> false
search("bad") -> true
search(".ad") -> true
search("b..") -> true
Note:
You may assume that all words are consist of lowercase letters a-z.
```

### Solution
```java
class WordDictionary {

    private class Node {

        Node[] alpha;
        boolean isEnd;

        public Node() {
            alpha = new Node[26];
            isEnd = false;
        }

    }

    Node root;

    /**
     * Initialize your data structure here.
     */
    public WordDictionary() {
        root = new Node();
    }

    /**
     * Adds a word into the data structure.
     */
    public void addWord(String word) {
        char[] c_list = word.toCharArray();
        Node cur = root;
        for (char c : c_list) {
            if (cur.alpha[c - 'a'] == null) {
                cur.alpha[c - 'a'] = new Node();
            }
            cur = cur.alpha[c - 'a'];
        }
        cur.isEnd = true;
    }

    /**
     * Returns if the word is in the data structure. A word could contain the dot character '.' to represent any one letter.
     */
    public boolean search(String word) {
        return searchUtil(word.toCharArray(), 0, root);
    }

    //main idea is when met a '.', use for loop to check.
    private boolean searchUtil(char[] word, int idx, Node cur) {
        if (idx == word.length) {
            return cur.isEnd;
        }
        if (word[idx] != '.') {
            return cur.alpha[word[idx] - 'a'] != null && searchUtil(word, idx + 1, cur.alpha[word[idx] - 'a']);
        } else {
            for (int i = 0; i < 26; i++) {
                if (cur.alpha[i] != null) {
                    if(searchUtil(word,idx+1,cur.alpha[i])){
                        return true;
                    }
                }
            }

        }
        return false;

    }
}

/**
 * Your WordDictionary object will be instantiated and called as such: WordDictionary obj = new WordDictionary(); obj.addWord(word); boolean param_2 =
 * obj.search(word);
 */

```

# 2019-11-06
## 166. Fraction to Recurring Decimal
### Description
Given two integers representing the numerator and denominator of a fraction, return the fraction in string format.

If the fractional part is repeating, enclose the repeating part in parentheses.

Example 1:

Input: numerator = 1, denominator = 2
Output: "0.5"
Example 2:

Input: numerator = 2, denominator = 1
Output: "2"
Example 3:

Input: numerator = 2, denominator = 3
Output: "0.(6)"

### Solution
```java
import java.util.HashMap;

class Solution {
    public String fractionToDecimal(int numerator, int denominator) {
        if (numerator == 0) {
            return "0";
        }
        StringBuilder sb = new StringBuilder();
        if ((numerator > 0) ^ (denominator > 0)) {
            sb.append("-");
        }
        long num = Math.abs((long) numerator);
        long den = Math.abs((long) denominator);

        sb.append(num / den);
        num %= den;
        if (num == 0)
            return sb.toString();

        sb.append(".");
        HashMap<Long, Integer> map = new HashMap<>();
        map.put(num, sb.length());

        //num 是个余数，如果这个余数出现过，那就会出现循环，就可以在这里结束。
        while (num != 0) {
            num *= 10;
            sb.append(num / den);
            num %= den;
            if (map.containsKey(num)) {
                int idx = map.get(num);
                //map记录了余数出现的位置，插入左括号。
                sb.insert(idx, "(");
                sb.append(")");
                return sb.toString();
            } else {
                map.put(num, sb.length());
            }
        }

        return sb.toString();
    }
}

```

# 2019-11-10
## 1041. Robot Bounded In Circle
### Description
On an infinite plane, a robot initially stands at (0, 0) and faces north.  The robot can receive one of three instructions:

"G": go straight 1 unit;
"L": turn 90 degrees to the left;
"R": turn 90 degress to the right.
The robot performs the instructions given in order, and repeats them forever.

Return true if and only if there exists a circle in the plane such that the robot never leaves the circle.

 
```
Example 1:

Input: "GGLLGG"
Output: true
Explanation: 
The robot moves from (0,0) to (0,2), turns 180 degrees, and then returns to (0,0).
When repeating these instructions, the robot remains in the circle of radius 2 centered at the origin.
Example 2:

Input: "GG"
Output: false
Explanation: 
The robot moves north indefinitely.
Example 3:

Input: "GL"
Output: true
Explanation: 
The robot moves from (0, 0) -> (0, 1) -> (-1, 1) -> (-1, 0) -> (0, 0) -> ...
```

Note:

1 <= instructions.length <= 100
instructions[i] is in {'G', 'L', 'R'}

### Solution
```java
class Solution {
    //(x,y) is the location of chopper.
    //d[i] is the direction he is facing.
    //i = (i + 1) % 4 will turn right
    //i = (i + 3) % 4 will turn left
Check the final status after instructions.
    public boolean isRobotBounded(String instructions) {
        int[][] dirs = new int[][][[0, 1], [1, 0], [0, -1], [-1, 0]];
        int x = 0, y = 0;
        int dir = 0;
        //if at the end of instruction, the robot does not face north,
        //then it will go back with 4 insc.
        for (char c : instructions.toCharArray()) {
            if (c == 'R') {
                dir = (dir + 1) % 4;
            } else if (c == 'L') {
                dir = (dir + 3) % 4;
            } else {
                x += dirs[dir][0];
                y += dirs[dir][1];
            }
        }
        return (x == 0 && y == 0) || dir != 0;
    }
}


```

## 1052. Grumpy Bookstore Owner
### Description
Today, the bookstore owner has a store open for customers.length minutes.  Every minute, some number of customers (customers[i]) enter the store, and all those customers leave after the end of that minute.

On some minutes, the bookstore owner is grumpy.  If the bookstore owner is grumpy on the i-th minute, grumpy[i] = 1, otherwise grumpy[i] = 0.  When the bookstore owner is grumpy, the customers of that minute are not satisfied, otherwise they are satisfied.

The bookstore owner knows a secret technique to keep themselves not grumpy for X minutes straight, but can only use it once.

Return the maximum number of customers that can be satisfied throughout the day.

 
```
Example 1:

Input: customers = [1,0,1,2,1,1,7,5], grumpy = [0,1,0,1,0,1,0,1], X = 3
Output: 16
Explanation: The bookstore owner keeps themselves not grumpy for the last 3 minutes. 
The maximum number of customers that can be satisfied = 1 + 1 + 1 + 1 + 7 + 5 = 16.
```

Note:

1 <= X <= customers.length == grumpy.length <= 20000
0 <= customers[i] <= 1000
0 <= grumpy[i] <= 1

### Solution
```java
class Solution {
    //sliding window to count max.
       public int maxSatisfied(int[] customers, int[] grumpy, int X) {
        int len = customers.length;
        int sum = 0;
        int sum_grumpy = 0;
        for (int i = 0; i < len; i++) {
            if (grumpy[i] == 0) {
                sum += customers[i];
                customers[i] = 0;
            } else {
                sum_grumpy += customers[i];
            }
        }
        if (len <= X) {
            return sum_grumpy + sum;
        }
        sum_grumpy = 0;
        int max_time = Integer.MIN_VALUE;
        for (int i = 0; i < X; i++) {
            sum_grumpy += customers[i];
        }
           max_time = Math.max(sum_grumpy,max_time);
        for (int i = 1; i < len - X +1; i++) {
            sum_grumpy -= customers[i-1] ;
            sum_grumpy += customers[i+X-1];
            max_time = Math.max(sum_grumpy,max_time);
        }
        return sum+max_time;
    }
}

```

### Description
Given a string s, partition s such that every substring of the partition is a palindrome.

Return all possible palindrome partitioning of s.
```
Example:

Input: "aab"
Output:
[
  ["aa","b"],
  ["a","a","b"]
]
```

### Solution
```java
import java.util.ArrayList;
import java.util.List;

class Solution {

    List<List<String>> res;
    List<String> currLst;

    public List<List<String>> partition(String s) {
        res = new ArrayList<>();
        currLst = new ArrayList<>();
        helper(s,0);
        return res;
    }

    private void helper(String s, int left){
        if(left >= s.length() && currLst.size()!=0){
            res.add(new ArrayList<>(currLst));
            return;
        }

        for(int i = left; i<s.length();i++){
            if(isPalindrome(s,left,i)){
                if(i == left){
                    currLst.add(Character.toString(s.charAt(i)));
                }else{
                    currLst.add(s.substring(left,i+1));
                }
                helper(s,i+1);
                currLst.remove(currLst.size()-1);
            }
        }
    }


    private boolean isPalindrome(String str, int l, int r){
        if(l==r) return true;
        while(l<r){
            if(str.charAt(l)!=str.charAt(r)) return false;
            l++;r--;
        }
        return true;
    }
}

```