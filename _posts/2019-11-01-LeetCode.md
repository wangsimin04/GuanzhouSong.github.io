---
layout: post
title:  LeetCode刷题笔记 11月
date:   2019-11-01 01:00:00 -0400
categories: 不周山
tag: Leetcode
---


* content
{:toc}

[Go to Leetcode](https://www.evernote.com/shard/s588/sh/3d35f48d-0506-4091-b714-2c7fd2cbe932/ffd5af217c35393980b68fbb86b3dc56)
# 2019-11-02
## 539. Minimum Time Difference
### Description
Given a list of 24-hour clock time points in "Hour:Minutes" format, find the minimum minutes difference between any two time points in the list.
Example 1:
Input: ["23:59","00:00"]
Output: 1
Note:
The number of time points in the given list is at least 2 and won't exceed 20000.
The input time is legal and ranges from 00:00 to 23:59.

### Solution
```java
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

class Solution {

    public int findMinDifference(List<String> timePoints) {
        int[] times = new int[timePoints.size()];
        int count = 0;
        for (String time : timePoints) {
            times[count++] = convert(time);
        }
        Arrays.sort(times);
        int min = Integer.MAX_VALUE;
        for(int i = 0;i<times.length-1;i++){
            min = Math.min(min,times[i+1]-times[i]);
        }
        min = Math.min(min,Math.abs(times[0]+24*60-times[times.length-1]));
        return min;

    }

    private int convert(String time) {
    	//use split will cause time waste.
    	//since you know the format, can call them directly.
        int hour = 10 * (time.charAt(0) - '0') + (time.charAt(1) - '0');
        int minute = 10 * (time.charAt(3) - '0') + (time.charAt(4) - '0');
        return hour * 60 + minute;
    }


}

```

## 24. Swap Nodes in Pairs
### Description
Given a linked list, swap every two adjacent nodes and return its head.

You may not modify the values in the list's nodes, only nodes itself may be changed.

 

Example:

Given 1->2->3->4, you should return the list as 2->1->4->3.

### Solution
```java
/**
 * Definition for singly-linked list. public class ListNode { int val; ListNode next; ListNode(int x) { val = x; } }
 */
class Solution {

    public ListNode swapPairs(ListNode head) {
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode pre = dummy;
        ListNode cur = dummy.next;
        while (cur != null && cur.next != null) {
            ListNode sec = cur.next;
            cur.next = sec.next;
            sec.next = cur;
            pre.next = sec;
            pre = cur;
            cur = cur.next;
        }
        return dummy.next;
    }
}

```

## 71. Simplify Path
### Description
Given an absolute path for a file (Unix-style), simplify it. Or in other words, convert it to the canonical path.

In a UNIX-style file system, a period . refers to the current directory. Furthermore, a double period .. moves the directory up a level. For more information, see: Absolute path vs relative path in Linux/Unix

Note that the returned canonical path must always begin with a slash /, and there must be only a single slash / between two directory names. The last directory name (if it exists) must not end with a trailing /. Also, the canonical path must be the shortest string representing the absolute path.

 
```
Example 1:

Input: "/home/"
Output: "/home"
Explanation: Note that there is no trailing slash after the last directory name.
Example 2:

Input: "/../"
Output: "/"
Explanation: Going one level up from the root directory is a no-op, as the root level is the highest level you can go.
Example 3:

Input: "/home//foo/"
Output: "/home/foo"
Explanation: In the canonical path, multiple consecutive slashes are replaced by a single one.
Example 4:

Input: "/a/./b/../../c/"
Output: "/c"
Example 5:

Input: "/a/../../b/../c//.//"
Output: "/c"
Example 6:

Input: "/a//b////c/d//././/.."
Output: "/a/b/c"
```

### Solution
```java
class Solution {
    public String simplifyPath(String path) {
        Deque<String> stack = new LinkedList<>();
        for (String s : path.split("/")) {
            if (s.equals("..")) {
                //use poll() can avoid empty with pop()
                stack.poll();
            } else if (!s.equals("") && !s.equals(".")) {
                stack.push(s);
            }
        }
        StringBuilder sb = new StringBuilder();
        if (stack.size() == 0) {
            return "/";
        }
        while (stack.size() != 0) {
            sb.append("/").append(stack.pollLast());
        }
        return sb.toString();
    }
}
```